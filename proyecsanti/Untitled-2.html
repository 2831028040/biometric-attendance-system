import pygame
import cv2
import mediapipe as mp
import numpy as np
import math
from collections import deque
import time

class ImprovedHandGestureController:
    """
    Controlador de gestos mejorado con detecci√≥n robusta de manos.
    Incluye preprocesamiento de imagen, diagn√≥sticos y auto-recuperaci√≥n.
    """
    
    def __init__(self, detection_confidence=0.5, tracking_confidence=0.5, smoothing_factor=0.3):
        """
        Inicializa el sistema con par√°metros optimizados para detecci√≥n robusta.
        
        Args:
            detection_confidence (float): Umbral reducido para mejor detecci√≥n inicial
            tracking_confidence (float): Umbral para seguimiento continuo
            smoothing_factor (float): Factor de suavizado
        """
        self.mp_hands = mp.solutions.hands
        self.mp_draw = mp.solutions.drawing_utils
        self.mp_drawing_styles = mp.solutions.drawing_styles
        
        # Configuraci√≥n mejorada de MediaPipe
        self.hands = self.mp_hands.Hands(
            static_image_mode=False,  # Modo video para mejor rendimiento
            max_num_hands=1,
            model_complexity=1,  # Balance entre precisi√≥n y velocidad
            min_detection_confidence=detection_confidence,
            min_tracking_confidence=tracking_confidence
        )
        
        # Buffers
        self.position_buffer = deque(maxlen=5)
        self.smoothing_factor = smoothing_factor
        self.last_position = None
        self.movement_buffer = deque(maxlen=15)
        
        # Estados
        self.gesture_states = {
            'current_gesture': 'none',
            'gesture_confidence': 0.0,
            'last_gesture': 'none',
            'gesture_timer': 0
        }
        
        self.last_palm_position = None
        
        # Sistema de diagn√≥stico
        self.detection_stats = {
            'total_frames': 0,
            'detected_frames': 0,
            'detection_rate': 0.0,
            'consecutive_failures': 0,
            'last_detection_time': time.time()
        }
        
        # Par√°metros de preprocesamiento
        self.use_preprocessing = True
        self.enhance_contrast = True
        self.target_brightness = 128  # Brillo objetivo
        
        # Auto-reinicio si hay fallos consecutivos
        self.max_consecutive_failures = 30
        
    def preprocess_frame(self, frame):
        """
        Preprocesa el frame para mejorar la detecci√≥n en condiciones sub√≥ptimas.
        
        Args:
            frame (numpy.ndarray): Frame original en BGR
            
        Returns:
            numpy.ndarray: Frame preprocesado
        """
        if not self.use_preprocessing:
            return frame
        
        # 1. Convertir a RGB
        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        
        # 2. Ajuste autom√°tico de brillo
        gray = cv2.cvtColor(rgb_frame, cv2.COLOR_RGB2GRAY)
        current_brightness = np.mean(gray)
        
        if current_brightness < 80:  # Muy oscuro
            # Aumentar brillo
            alpha = self.target_brightness / (current_brightness + 1e-6)
            alpha = min(alpha, 2.0)  # Limitar ganancia
            rgb_frame = cv2.convertScaleAbs(rgb_frame, alpha=alpha, beta=0)
            
        elif current_brightness > 180:  # Muy brillante
            # Reducir brillo
            alpha = self.target_brightness / (current_brightness + 1e-6)
            alpha = max(alpha, 0.5)
            rgb_frame = cv2.convertScaleAbs(rgb_frame, alpha=alpha, beta=0)
        
        # 3. Mejorar contraste si est√° habilitado
        if self.enhance_contrast:
            # CLAHE (Contrast Limited Adaptive Histogram Equalization)
            lab = cv2.cvtColor(rgb_frame, cv2.COLOR_RGB2LAB)
            l, a, b = cv2.split(lab)
            
            clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
            l = clahe.apply(l)
            
            lab = cv2.merge([l, a, b])
            rgb_frame = cv2.cvtColor(lab, cv2.COLOR_LAB2RGB)
        
        # 4. Reducci√≥n de ruido ligera
        rgb_frame = cv2.bilateralFilter(rgb_frame, 5, 50, 50)
        
        return rgb_frame
    
    def reinitialize_detector(self):
        """
        Re-inicializa el detector de MediaPipe para recuperarse de fallos.
        """
        print("üîÑ Re-inicializando detector de manos...")
        self.hands.close()
        
        self.hands = self.mp_hands.Hands(
            static_image_mode=False,
            max_num_hands=1,
            model_complexity=1,
            min_detection_confidence=0.5,
            min_tracking_confidence=0.5
        )
        
        self.detection_stats['consecutive_failures'] = 0
        print("‚úÖ Detector re-inicializado")
    
    def calculate_hand_landmarks(self, frame):
        """
        Procesa frame con detecci√≥n mejorada y diagn√≥sticos.
        
        Args:
            frame (numpy.ndarray): Frame de entrada en formato BGR
            
        Returns:
            tuple: (frame_procesado, landmarks_dict)
        """
        self.detection_stats['total_frames'] += 1
        
        # Preprocesar frame
        rgb_frame = self.preprocess_frame(frame)
        
        # Procesar con MediaPipe
        results = self.hands.process(rgb_frame)
        
        landmarks_data = {
            'hands_detected': False,
            'palm_center': None,
            'static_gesture': 'none',
            'dynamic_gesture': 'none',
            'gesture_confidence': 0.0,
            'movement_velocity': 0.0,
            'movement_direction': None,
            'detection_quality': 0.0
        }
        
        if results.multi_hand_landmarks:
            self.detection_stats['detected_frames'] += 1
            self.detection_stats['consecutive_failures'] = 0
            self.detection_stats['last_detection_time'] = time.time()
            landmarks_data['hands_detected'] = True
            
            hand_landmarks = results.multi_hand_landmarks[0]
            
            # Calcular calidad de detecci√≥n (basado en visibilidad)
            visibility_scores = [lm.visibility if hasattr(lm, 'visibility') else 1.0 
                               for lm in hand_landmarks.landmark]
            landmarks_data['detection_quality'] = np.mean(visibility_scores)
            
            landmarks_array = np.array([[lm.x, lm.y, lm.z] for lm in hand_landmarks.landmark])
            
            # Extraer caracter√≠sticas
            palm_center = np.mean(landmarks_array[[0, 5, 9, 13, 17]], axis=0)
            finger_extensions = self._analyze_finger_extensions(landmarks_array)
            
            # Clasificar gesto est√°tico
            static_gesture = self._classify_static_gesture(finger_extensions, landmarks_array)
            landmarks_data['static_gesture'] = static_gesture
            landmarks_data['palm_center'] = palm_center
            
            # Detectar movimiento din√°mico
            if self.last_palm_position is not None:
                movement = palm_center[:2] - self.last_palm_position[:2]
                velocity = np.linalg.norm(movement)
                
                self.movement_buffer.append((movement, velocity))
                
                if velocity > 0.02:
                    dynamic_gesture, confidence = self._detect_dynamic_gesture()
                    if dynamic_gesture != 'none':
                        landmarks_data['dynamic_gesture'] = dynamic_gesture
                        landmarks_data['gesture_confidence'] = confidence
                        landmarks_data['movement_velocity'] = velocity
            
            self.last_palm_position = palm_center
            
            # Visualizaci√≥n mejorada de landmarks
            self.mp_draw.draw_landmarks(
                rgb_frame, 
                hand_landmarks, 
                self.mp_hands.HAND_CONNECTIONS,
                self.mp_drawing_styles.get_default_hand_landmarks_style(),
                self.mp_drawing_styles.get_default_hand_connections_style()
            )
            
        else:
            # Sin detecci√≥n
            self.detection_stats['consecutive_failures'] += 1
            self.movement_buffer.clear()
            self.last_palm_position = None
            
            # Auto-reinicio si hay muchos fallos
            if self.detection_stats['consecutive_failures'] >= self.max_consecutive_failures:
                self.reinitialize_detector()
        
        # Calcular tasa de detecci√≥n
        if self.detection_stats['total_frames'] > 0:
            self.detection_stats['detection_rate'] = (
                self.detection_stats['detected_frames'] / 
                self.detection_stats['total_frames']
            )
        
        return cv2.cvtColor(rgb_frame, cv2.COLOR_RGB2BGR), landmarks_data
    
    def _analyze_finger_extensions(self, landmarks):
        """Analiza extensi√≥n de dedos con l√≥gica mejorada."""
        finger_tips = [4, 8, 12, 16, 20]
        finger_pips = [3, 6, 10, 14, 18]
        finger_mcps = [2, 5, 9, 13, 17]
        
        extensions = {}
        finger_names = ['thumb', 'index', 'middle', 'ring', 'pinky']
        
        for i, (tip, pip, mcp, name) in enumerate(zip(finger_tips, finger_pips, finger_mcps, finger_names)):
            tip_to_pip = np.linalg.norm(landmarks[tip][:2] - landmarks[pip][:2])
            pip_to_mcp = np.linalg.norm(landmarks[pip][:2] - landmarks[mcp][:2])
            
            if i == 0:  # Pulgar
                # An√°lisis mejorado de pulgar considerando eje X
                wrist_x = landmarks[0][0]
                thumb_tip_x = landmarks[tip][0]
                thumb_mcp_x = landmarks[mcp][0]
                
                # Pulgar extendido si est√° alejado del centro de la mano
                extensions[name] = abs(thumb_tip_x - wrist_x) > abs(thumb_mcp_x - wrist_x) * 1.2
            else:
                # Dedos normales: comparar distancias
                extensions[name] = tip_to_pip > pip_to_mcp * 0.75  # Umbral m√°s permisivo
            
        return extensions
    
    def _classify_static_gesture(self, finger_extensions, landmarks):
        """Clasificaci√≥n de gestos con l√≥gica refinada."""
        extended_count = sum(finger_extensions.values())
        
        # PU√ëO CERRADO
        if extended_count == 0:
            return 'fist'
        
        # MANO ABIERTA
        elif extended_count >= 4:
            return 'open_palm'
        
        # DEDO √çNDICE
        elif extended_count == 1 and finger_extensions['index']:
            return 'point'
        
        # PAZ (V)
        elif extended_count == 2 and finger_extensions['index'] and finger_extensions['middle']:
            return 'peace'
        
        # PULGAR ARRIBA
        elif extended_count == 1 and finger_extensions['thumb']:
            return 'thumb_up'
        
        # PINZA
        elif finger_extensions['thumb'] and finger_extensions['index']:
            thumb_tip = landmarks[4][:2]
            index_tip = landmarks[8][:2]
            distance = np.linalg.norm(thumb_tip - index_tip)
            
            if distance < 0.08:  # Umbral m√°s permisivo
                return 'pinch'
            else:
                return 'l_shape'
        
        else:
            return 'custom'
    
    def _detect_dynamic_gesture(self):
        """Detecci√≥n de gestos din√°micos."""
        if len(self.movement_buffer) < 10:
            return 'none', 0.0
        
        recent_movements = list(self.movement_buffer)[-10:]
        movements = np.array([m[0] for m in recent_movements])
        velocities = np.array([m[1] for m in recent_movements])
        
        total_movement = np.sum(movements, axis=0)
        avg_velocity = np.mean(velocities)
        
        if avg_velocity < 0.015:
            return 'none', 0.0
        
        angle = np.arctan2(total_movement[1], total_movement[0])
        magnitude = np.linalg.norm(total_movement)
        
        # Swipes
        if magnitude > 0.12:  # Umbral m√°s permisivo
            if abs(angle) < np.pi / 4:
                return 'swipe_right', 0.9
            elif abs(angle) > 3 * np.pi / 4:
                return 'swipe_left', 0.9
            elif np.pi / 4 < angle < 3 * np.pi / 4:
                return 'swipe_down', 0.9
            elif -3 * np.pi / 4 < angle < -np.pi / 4:
                return 'swipe_up', 0.9
        
        # C√≠rculos
        if len(self.movement_buffer) >= 15:
            angles = []
            for i in range(len(movements) - 1):
                a = np.arctan2(movements[i][1], movements[i][0])
                angles.append(a)
            
            if len(angles) > 5:
                angle_changes = np.diff(angles)
                angle_changes = np.where(angle_changes > np.pi, angle_changes - 2*np.pi, angle_changes)
                angle_changes = np.where(angle_changes < -np.pi, angle_changes + 2*np.pi, angle_changes)
                
                total_rotation = np.sum(angle_changes)
                
                if abs(total_rotation) > np.pi * 1.5:
                    if total_rotation > 0:
                        return 'circle_ccw', 0.85
                    else:
                        return 'circle_cw', 0.85
        
        return 'none', 0.0
    
    def get_smoothed_position(self, raw_position, frame_width):
        """Suavizado de posici√≥n con filtro IIR."""
        if raw_position is None:
            return self.last_position if self.last_position else frame_width // 2
        
        screen_pos = raw_position[0] * frame_width
        
        if self.last_position is not None:
            smoothed_pos = (
                self.smoothing_factor * screen_pos + 
                (1 - self.smoothing_factor) * self.last_position
            )
        else:
            smoothed_pos = screen_pos
        
        self.last_position = smoothed_pos
        return int(smoothed_pos)
    
    def get_detection_stats(self):
        """Retorna estad√≠sticas de detecci√≥n para diagn√≥stico."""
        return self.detection_stats.copy()


class EnhancedBreakoutGame:
    """Juego Breakout con sistema de detecci√≥n mejorado."""
    
    def __init__(self, width=1000, height=800):
        pygame.init()
        
        self.WIDTH = width
        self.HEIGHT = height
        self.screen = pygame.display.set_mode((self.WIDTH, self.HEIGHT))
        pygame.display.set_caption("Breakout - Detecci√≥n Mejorada")
        self.clock = pygame.time.Clock()
        
        # Controlador mejorado
        self.gesture_controller = ImprovedHandGestureController(
            detection_confidence=0.5,  # M√°s permisivo
            tracking_confidence=0.5,
            smoothing_factor=0.3
        )
        
        # Configuraci√≥n de c√°mara optimizada
        self.camera = cv2.VideoCapture(0)
        self.camera.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        self.camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
        self.camera.set(cv2.CAP_PROP_FPS, 30)
        self.camera.set(cv2.CAP_PROP_BUFFERSIZE, 1)  # Reducir latencia
        
        # Ajustes de c√°mara para mejor detecci√≥n
        self.camera.set(cv2.CAP_PROP_AUTO_EXPOSURE, 1)  # Auto-exposici√≥n
        self.camera.set(cv2.CAP_PROP_AUTOFOCUS, 1)  # Auto-foco
        
        # Estados del juego
        self.game_state = 'playing'
        self.score = 0
        self.lives = 3
        
        # Control de gestos
        self.gesture_cooldown = 0
        self.gesture_cooldown_duration = 45
        self.ball_speed_boost = False
        self.boost_timer = 0
        self.last_processed_gesture = 'none'
        
        # Informaci√≥n de detecci√≥n
        self.current_detected_gesture = 'none'
        self.gesture_display_timer = 0
        self.show_diagnostics = True  # Mostrar info de diagn√≥stico
        
        self._initialize_game_elements()
        
    def _initialize_game_elements(self):
        """Inicializa elementos del juego."""
        self.paddle = {
            'width': 150,
            'height': 20,
            'x': self.WIDTH // 2 - 75,
            'y': self.HEIGHT - 100,
            'speed': 0,
            'color': (100, 200, 255),
            'base_width': 150
        }
        
        self.ball = {
            'x': self.WIDTH // 2,
            'y': self.HEIGHT // 2,
            'radius': 10,
            'speed_x': 6,
            'speed_y': -6,
            'color': (255, 100, 100),
            'launched': False,
            'base_speed': 6
        }
        
        self.blocks = []
        block_rows, block_cols = 5, 10
        block_width = self.WIDTH // block_cols
        block_height = 30
        
        colors = [(255, 0, 0), (255, 165, 0), (255, 255, 0), (0, 255, 0), (0, 0, 255)]
        
        for row in range(block_rows):
            for col in range(block_cols):
                self.blocks.append({
                    'x': col * block_width,
                    'y': 50 + row * block_height,
                    'width': block_width - 2,
                    'height': block_height - 2,
                    'color': colors[row],
                    'active': True
                })
    
    def process_gesture_input(self):
        """Procesa entrada gestual con diagn√≥sticos."""
        ret, frame = self.camera.read()
        if not ret:
            print("‚ö†Ô∏è Error al capturar frame de c√°mara")
            return None
        
        frame = cv2.flip(frame, 1)
        
        # Procesamiento con sistema mejorado
        processed_frame, landmarks_data = self.gesture_controller.calculate_hand_landmarks(frame)
        
        if landmarks_data['hands_detected'] and landmarks_data['palm_center'] is not None:
            # Control de paddle
            palm_x = self.gesture_controller.get_smoothed_position(
                landmarks_data['palm_center'], self.WIDTH
            )
            
            self.paddle['x'] = max(0, min(palm_x - self.paddle['width'] // 2, 
                                         self.WIDTH - self.paddle['width']))
            
            # Procesamiento de gestos
            static_gesture = landmarks_data['static_gesture']
            dynamic_gesture = landmarks_data['dynamic_gesture']
            confidence = landmarks_data['gesture_confidence']
            
            if dynamic_gesture != 'none' and self.gesture_cooldown <= 0:
                if dynamic_gesture != self.last_processed_gesture:
                    self._handle_dynamic_gesture(dynamic_gesture, confidence)
                    self.gesture_cooldown = self.gesture_cooldown_duration
                    self.last_processed_gesture = dynamic_gesture
                    self.current_detected_gesture = dynamic_gesture
                    self.gesture_display_timer = 60
            elif static_gesture != 'none' and self.gesture_cooldown <= 0:
                if static_gesture != self.last_processed_gesture:
                    self._handle_static_gesture(static_gesture)
                    self.gesture_cooldown = self.gesture_cooldown_duration // 2
                    self.last_processed_gesture = static_gesture
                    self.current_detected_gesture = static_gesture
                    self.gesture_display_timer = 60
        
        if self.gesture_cooldown > 0:
            self.gesture_cooldown -= 1
        
        if self.gesture_display_timer > 0:
            self.gesture_display_timer -= 1
            if self.gesture_display_timer == 0:
                self.current_detected_gesture = 'none'
        
        if self.boost_timer > 0:
            self.boost_timer -= 1
            if self.boost_timer == 0:
                self.ball_speed_boost = False
                self.ball['color'] = (255, 100, 100)
        
        return processed_frame
    
    def _handle_static_gesture(self, gesture):
        """Maneja gestos est√°ticos."""
        if gesture == 'fist':
            if self.game_state == 'playing':
                self.toggle_pause()
        elif gesture == 'open_palm':
            if self.game_state == 'paused':
                self.toggle_pause()
            elif not self.ball['launched']:
                self.ball['launched'] = True
        elif gesture == 'pinch':
            if not self.ball['launched']:
                self.ball['launched'] = True
        elif gesture == 'thumb_up':
            if not self.ball_speed_boost and self.ball['launched']:
                self.ball['speed_x'] *= 1.3
                self.ball['speed_y'] *= 1.3
                self.ball_speed_boost = True
                self.boost_timer = 120
                self.ball['color'] = (255, 255, 0)
    
    def _handle_dynamic_gesture(self, gesture, confidence):
        """Maneja gestos din√°micos."""
        if gesture == 'swipe_left':
            self.paddle['x'] = max(0, self.paddle['x'] - 150)
        elif gesture == 'swipe_right':
            self.paddle['x'] = min(self.WIDTH - self.paddle['width'], 
                                   self.paddle['x'] + 150)
        elif gesture == 'swipe_up':
            if not self.ball_speed_boost and self.ball['launched']:
                self.ball['speed_x'] *= 1.5
                self.ball['speed_y'] *= 1.5
                self.ball_speed_boost = True
                self.boost_timer = 180
                self.ball['color'] = (255, 255, 0)
        elif gesture == 'swipe_down':
            if self.ball['launched']:
                if self.ball_speed_boost:
                    self.ball['speed_x'] /= 1.5
                    self.ball['speed_y'] /= 1.5
                    self.ball_speed_boost = False
                    self.boost_timer = 0
                    self.ball['color'] = (255, 100, 100)
                else:
                    self.ball['speed_x'] *= 0.8
                    self.ball['speed_y'] *= 0.8
        elif gesture == 'circle_cw' or gesture == 'circle_ccw':
            self.paddle['width'] = min(300, self.paddle['width'] + 30)
    
    def update_game_physics(self):
        """Actualiza f√≠sica del juego."""
        if self.game_state != 'playing':
            return
        
        if not self.ball['launched']:
            self.ball['x'] = self.paddle['x'] + self.paddle['width'] // 2
            self.ball['y'] = self.paddle['y'] - self.ball['radius'] - 5
            return
        
        self.ball['x'] += self.ball['speed_x']
        self.ball['y'] += self.ball['speed_y']
        
        if (self.ball['x'] - self.ball['radius'] <= 0 or 
            self.ball['x'] + self.ball['radius'] >= self.WIDTH):
            self.ball['speed_x'] *= -1
        
        if self.ball['y'] - self.ball['radius'] <= 0:
            self.ball['speed_y'] *= -1
        
        if self.ball['y'] + self.ball['radius'] >= self.HEIGHT:
            self.lives -= 1
            if self.lives <= 0:
                self.game_state = 'game_over'
            else:
                self._reset_ball()
        
        paddle_rect = pygame.Rect(
            self.paddle['x'], self.paddle['y'],
            self.paddle['width'], self.paddle['height']
        )
        
        ball_rect = pygame.Rect(
            self.ball['x'] - self.ball['radius'],
            self.ball['y'] - self.ball['radius'],
            self.ball['radius'] * 2,
            self.ball['radius'] * 2
        )
        
        if paddle_rect.colliderect(ball_rect) and self.ball['speed_y'] > 0:
            impact_point = (self.ball['x'] - self.paddle['x']) / self.paddle['width']
            angle_factor = (impact_point - 0.5) * 2
            
            self.ball['speed_y'] *= -1
            self.ball['speed_x'] += angle_factor * 3
        
        for block in self.blocks:
            if not block['active']:
                continue
            
            block_rect = pygame.Rect(
                block['x'], block['y'],
                block['width'], block['height']
            )
            
            if block_rect.colliderect(ball_rect):
                block['active'] = False
                self.ball['speed_y'] *= -1
                self.score += 10
                break
        
        if all(not block['active'] for block in self.blocks):
            self.game_state = 'victory'
    
    def _reset_ball(self):
        """Reinicia pelota."""
        self.ball['x'] = self.WIDTH // 2
        self.ball['y'] = self.HEIGHT // 2
        self.ball['speed_x'] = self.ball['base_speed'] if np.random.random() > 0.5 else -self.ball['base_speed']
        self.ball['speed_y'] = -self.ball['base_speed']
        self.ball['launched'] = False
        self.ball_speed_boost = False
        self.boost_timer = 0
        self.ball['color'] = (255, 100, 100)
        self.paddle['width'] = self.paddle['base_width']
    
    def toggle_pause(self):
        """Alterna pausa."""
        if self.game_state == 'playing':
            self.game_state = 'paused'
        elif self.game_state == 'paused':
            self.game_state = 'playing'
    
    def render_frame(self, camera_frame=None):
        """Renderiza frame con diagn√≥sticos."""
        self.screen.fill((20, 20, 40))
        
        # Overlay de c√°mara mejorado
        if camera_frame is not None:
            cam_surface = self._convert_cv_to_pygame(camera_frame)
            cam_surface = pygame.transform.scale(cam_surface, (320, 240))
            cam_surface.set_alpha(200)
            self.screen.blit(cam_surface, (self.WIDTH - 330, 10))
            
            # Marco para la c√°mara
            pygame.draw.rect(self.screen, (100, 255, 100) if self.gesture_controller.detection_stats['consecutive_failures'] == 0 else (255, 100, 100),
                           (self.WIDTH - 330, 10, 320, 240), 3)
        
        # Elementos del juego
        paddle_color = self.paddle['color']
        if self.ball_speed_boost:
            paddle_color = (255, 255, 100)
            
        pygame.draw.rect(
            self.screen, paddle_color,
            (self.paddle['x'], self.paddle['y'],
             self.paddle['width'], self.paddle['height'])
        )
        
        pygame.draw.circle(
            self.screen, self.ball['color'],
            (int(self.ball['x']), int(self.ball['y'])),
            self.ball['radius']
        )
        
        for block in self.blocks:
            if block['active']:
                pygame.draw.rect(
                    self.screen, block['color'],
                    (block['x'], block['y'], block['width'], block['height'])
                )
        
        self._render_ui()
        
        pygame.display.flip()
    
    def _convert_cv_to_pygame(self, cv_frame):
        """Convierte frame de OpenCV a pygame."""
        cv_frame = cv2.cvtColor(cv_frame, cv2.COLOR_BGR2RGB)
        cv_frame = np.rot90(cv_frame)
        return pygame.surfarray.make_surface(cv_frame)
    
    def _render_ui(self):
        """Renderiza UI con diagn√≥sticos."""
        font_large = pygame.font.Font(None, 48)
        font_medium = pygame.font.Font(None, 36)
        font_small = pygame.font.Font(None, 24)
        
        # Score y vidas
        score_text = font_medium.render(f"Score: {self.score}", True, (255, 255, 255))
        self.screen.blit(score_text, (10, 10))
        
        lives_text = font_medium.render(f"Vidas: {self.lives}", True, (255, 255, 255))
        self.screen.blit(lives_text, (10, 50))
        
        # Diagn√≥sticos de detecci√≥n
        if self.show_diagnostics:
            stats = self.gesture_controller.get_detection_stats()
            
            # Tasa de detecci√≥n
            detection_color = (0, 255, 0) if stats['detection_rate'] > 0.7 else (255, 255, 0) if stats['detection_rate'] > 0.4 else (255, 0, 0)
            detection_text = font_small.render(
                f"Detecci√≥n: {stats['detection_rate']*100:.1f}%", 
                True, detection_color
            )
            self.screen.blit(detection_text, (10, 90))
            
            # Estado de detecci√≥n actual
            if stats['consecutive_failures'] == 0:
                status_text = font_small.render("‚úì Mano detectada", True, (0, 255, 0))
            elif stats['consecutive_failures'] < 15:
                status_text = font_small.render("‚ö† Buscando mano...", True, (255, 255, 0))
            else:
                status_text = font_small.render("‚úó Sin detecci√≥n", True, (255, 0, 0))
            self.screen.blit(status_text, (10, 115))
        
        # Gesto actual
        if self.current_detected_gesture != 'none':
            gesture_names = {
                'swipe_left': '‚Üê SWIPE IZQUIERDA',
                'swipe_right': 'SWIPE DERECHA ‚Üí',
                'swipe_up': '‚Üë SWIPE ARRIBA',
                'swipe_down': '‚Üì SWIPE ABAJO',
                'circle_cw': '‚Üª C√çRCULO HORARIO',
                'circle_ccw': '‚Ü∫ C√çRCULO ANTIHORARIO',
                'fist': '‚úä PU√ëO (PAUSA)',
                'open_palm': '‚úã MANO ABIERTA',
                'pinch': 'ü§è PINZA (LANZAR)',
                'thumb_up': 'üëç PULGAR ARRIBA',
                'peace': '‚úåÔ∏è PAZ'
            }
            
            display_name = gesture_names.get(self.current_detected_gesture, self.current_detected_gesture)
            gesture_text = font_large.render(display_name, True, (0, 255, 255))
            text_rect = gesture_text.get_rect(center=(self.WIDTH//2, 150))
            
            bg_rect = pygame.Surface((text_rect.width + 40, text_rect.height + 20))
            bg_rect.set_alpha(180)
            bg_rect.fill((0, 0, 0))
            self.screen.blit(bg_rect, (text_rect.x - 20, text_rect.y - 10))
            
            self.screen.blit(gesture_text, text_rect)
        
        if self.ball_speed_boost:
            boost_text = font_large.render("‚ö° SPEED BOOST ACTIVO ‚ö°", True, (255, 255, 0))
            text_rect = boost_text.get_rect(center=(self.WIDTH//2, 220))
            self.screen.blit(boost_text, text_rect)
        
        # Instrucciones compactas
        y_offset = self.HEIGHT - 180
        
        instructions = [
            "GESTOS: ‚úäPausar | ‚úãReanudar/Lanzar | üëçBoost | ‚Üê‚Üí‚Üë‚ÜìSwipes | ‚ÜªExpandir",
            "TECLADO: SPACE=Pausa | R=Reiniciar | D=Diagn√≥sticos | ESC=Salir"
        ]
        
        for instruction in instructions:
            inst_text = font_small.render(instruction, True, (180, 220, 255))
            self.screen.blit(inst_text, (10, y_offset))
            y_offset += 25
        
        # Estados del juego
        if self.game_state == 'paused':
            pause_text = font_large.render("‚è∏ PAUSADO", True, (255, 255, 0))
            text_rect = pause_text.get_rect(center=(self.WIDTH//2, self.HEIGHT//2))
            
            bg_rect = pygame.Surface((text_rect.width + 60, text_rect.height + 40))
            bg_rect.set_alpha(220)
            bg_rect.fill((0, 0, 0))
            self.screen.blit(bg_rect, (text_rect.x - 30, text_rect.y - 20))
            
            self.screen.blit(pause_text, text_rect)
            
            resume_text = font_small.render("Haz MANO ABIERTA para reanudar", True, (255, 255, 255))
            resume_rect = resume_text.get_rect(center=(self.WIDTH//2, self.HEIGHT//2 + 50))
            self.screen.blit(resume_text, resume_rect)
            
        elif self.game_state == 'game_over':
            game_over_text = font_large.render("üíÄ GAME OVER üíÄ", True, (255, 0, 0))
            text_rect = game_over_text.get_rect(center=(self.WIDTH//2, self.HEIGHT//2 - 40))
            
            bg_rect = pygame.Surface((text_rect.width + 60, 200))
            bg_rect.set_alpha(220)
            bg_rect.fill((0, 0, 0))
            self.screen.blit(bg_rect, (text_rect.x - 30, text_rect.y - 20))
            
            self.screen.blit(game_over_text, text_rect)
            
            final_score = font_medium.render(f"Score Final: {self.score}", True, (255, 255, 255))
            score_rect = final_score.get_rect(center=(self.WIDTH//2, self.HEIGHT//2 + 20))
            self.screen.blit(final_score, score_rect)
            
            restart_text = font_small.render("Presiona R para reiniciar", True, (255, 255, 255))
            restart_rect = restart_text.get_rect(center=(self.WIDTH//2, self.HEIGHT//2 + 60))
            self.screen.blit(restart_text, restart_rect)
            
        elif self.game_state == 'victory':
            victory_text = font_large.render("üéâ ¬°VICTORIA! üéâ", True, (0, 255, 0))
            text_rect = victory_text.get_rect(center=(self.WIDTH//2, self.HEIGHT//2 - 40))
            
            bg_rect = pygame.Surface((text_rect.width + 60, 200))
            bg_rect.set_alpha(220)
            bg_rect.fill((0, 0, 0))
            self.screen.blit(bg_rect, (text_rect.x - 30, text_rect.y - 20))
            
            self.screen.blit(victory_text, text_rect)
            
            final_score = font_medium.render(f"Score Final: {self.score}", True, (255, 255, 255))
            score_rect = final_score.get_rect(center=(self.WIDTH//2, self.HEIGHT//2 + 20))
            self.screen.blit(final_score, score_rect)
            
            restart_text = font_small.render("Presiona R para reiniciar", True, (255, 255, 255))
            restart_rect = restart_text.get_rect(center=(self.WIDTH//2, self.HEIGHT//2 + 60))
            self.screen.blit(restart_text, restart_rect)
        
        if not self.ball['launched'] and self.game_state == 'playing':
            launch_text = font_medium.render("Haz PINZA o MANO ABIERTA para lanzar", True, (255, 255, 100))
            text_rect = launch_text.get_rect(center=(self.WIDTH//2, self.HEIGHT//2 + 100))
            self.screen.blit(launch_text, text_rect)
    
    def run(self):
        """Loop principal."""
        running = True
        
        print("\n" + "="*70)
        print("  BREAKOUT - SISTEMA DE DETECCI√ìN MEJORADO")
        print("="*70)
        print("\nüîç MEJORAS IMPLEMENTADAS:")
        print("  ‚Ä¢ Preprocesamiento autom√°tico de imagen (brillo/contraste)")
        print("  ‚Ä¢ Umbrales de detecci√≥n m√°s permisivos")
        print("  ‚Ä¢ Auto-reinicio del detector en caso de fallos")
        print("  ‚Ä¢ Diagn√≥sticos en tiempo real")
        print("  ‚Ä¢ Filtrado de ruido bilateral")
        print("\nüí° CONSEJOS PARA MEJOR DETECCI√ìN:")
        print("  1. Aseg√∫rate de tener buena iluminaci√≥n")
        print("  2. Coloca tu mano a 30-60cm de la c√°mara")
        print("  3. Fondo contrastante (evita fondos con piel o manos)")
        print("  4. Mano completamente visible en el frame")
        print("  5. Observa el indicador de detecci√≥n (verde=bueno)")
        print("\nüìä DIAGN√ìSTICOS:")
        print("  ‚Ä¢ Verde: Detecci√≥n activa")
        print("  ‚Ä¢ Amarillo: Buscando mano")
        print("  ‚Ä¢ Rojo: Sin detecci√≥n")
        print("  ‚Ä¢ Presiona 'D' para toggle diagn√≥sticos")
        print("="*70 + "\n")
        
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        self.toggle_pause()
                    elif event.key == pygame.K_r and self.game_state in ['game_over', 'victory']:
                        self._initialize_game_elements()
                        self.score = 0
                        self.lives = 3
                        self.game_state = 'playing'
                        self.ball_speed_boost = False
                        self.boost_timer = 0
                        self.current_detected_gesture = 'none'
                        self.gesture_display_timer = 0
                    elif event.key == pygame.K_d:
                        self.show_diagnostics = not self.show_diagnostics
                        print(f"üìä Diagn√≥sticos: {'ON' if self.show_diagnostics else 'OFF'}")
                    elif event.key == pygame.K_ESCAPE:
                        running = False
            
            camera_frame = self.process_gesture_input()
            self.update_game_physics()
            self.render_frame(camera_frame)
            
            self.clock.tick(60)
        
        # Mostrar estad√≠sticas finales
        stats = self.gesture_controller.get_detection_stats()
        print("\n" + "="*70)
        print("üìä ESTAD√çSTICAS FINALES DE DETECCI√ìN:")
        print(f"  ‚Ä¢ Frames totales: {stats['total_frames']}")
        print(f"  ‚Ä¢ Frames con detecci√≥n: {stats['detected_frames']}")
        print(f"  ‚Ä¢ Tasa de detecci√≥n: {stats['detection_rate']*100:.1f}%")
        print("="*70 + "\n")
        
        self.camera.release()
        cv2.destroyAllWindows()
        pygame.quit()
        print("¬°Gracias por jugar! üëã\n")


def main():
    """Funci√≥n principal."""
    try:
        print("\nüéÆ Inicializando sistema...")
        print("üìπ Verificando c√°mara...")
        
        # Verificar c√°mara
        test_cam = cv2.VideoCapture(0)
        if not test_cam.isOpened():
            print("‚ùå ERROR: No se puede acceder a la c√°mara")
            print("üí° Verifica que:")
            print("   ‚Ä¢ La c√°mara est√© conectada")
            print("   ‚Ä¢ No est√© siendo usada por otra aplicaci√≥n")
            print("   ‚Ä¢ Tengas permisos de c√°mara")
            return
        test_cam.release()
        
        print("‚úÖ C√°mara detectada correctamente")
        print("üöÄ Iniciando juego...\n")
        
        game = EnhancedBreakoutGame(width=1200, height=900)
        game.run()
        
    except Exception as e:
        print(f"\n‚ùå Error durante la ejecuci√≥n: {e}")
        import traceback
        traceback.print_exc()
        print("\nüí° Aseg√∫rate de tener instaladas las dependencias:")
        print("   pip install pygame opencv-python mediapipe numpy")


if __name__ == "__main__":
    main()